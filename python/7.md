# Dynamic programming

Dynamic Programming 을 사용하기 위해서는 필요한 조건이 두가지 있다.
1. 최적 부분 구조 ( Optimal Substructure )
2. 중복되는 부분 문제 ( Overlapping Subproblems )

### 1. 최적 부분 구조
**최적 부분 구조**가 있다는 건...
**부분 문제**들의 **최적의 답**을 이용해서
**기존 문제**의 **최적의 답**을 구할 수 있다는 것

예) 피보나치 수 : fib(5)를 구하기 위해서는 fib(4)를 구하는 부분 문제와 fib(3)을 구하는 부분문제를 먼저 해결해야 함. 이 두 부분문제의 최적의 답을 구하면 그걸 이용해서 기존 문제의 최적의 답을 구할 수 있다. 그렇기 때문에 피보나치 문제는 최적 부분 구조를 가지고 있다고 말할 수 있다.

### 2. 중복되는 부분 문제
n번째 피보나치의 수를 계산해주는 함수 fib가 있다고 가정했을 때, fib(5)를 해결하기 위해서는 fib(4)라는 부분문제와 fib(3)이라는 부분문제를 해결해야 한다. 그런데 fib(4)를 해결하기 위해서는 또 fib(3)이라는 부분문제와 fib(2)라는 부분문제를 해결해야 한다. 그리고 fib(3)을 해결하기 위해서는 또 fib(2)와 fib(1)을 해결해야 한다. 

이 때, 중복되는 부분 문제들이 생긴다. *(예: fib(3)을 2번 계산해야 함)* 
fib(7)을 계산하게 된다면 중복되는 부분 문제는 더 많아진다. 이렇게 중복되는 부분 문제들을 여러번 계산하는 것은 매우 비효율적이므로 이런 문제를 해결하기 위해 동적 프로그래밍(Dynamic Programming)을 한다.

~~그러나 문제를 부분문제로 나눈다고 해서 항상 부분 문제가 생기는 것은 아님! (예: 합병정렬)~~


따라서 어떤 문제에 **최적 부분 구조**가 있다 >> **부분 문제**들의 **최적의 답**을 이용해서 **기존 문제**를 풀 수 있다 ( =기존 문제를 부분 문제로 나눠서 풀 수 있다) >> **중복되는 부분 문제**들이 있을 수 있다 >> 똑같은 문제를 여러번 풀어야 하는 비효율 발생 >> 이를 해결하는 알고리즘 패러다임 = **Dynamic Programming**

## Dynamic Programming

한 번 계산한 결과를 **재활용하는 방식**

Dynamic Programming 을 구현하는 방법은 다시 2가지로 나뉜다.

 1. Memoization
 2. Tabulation
 
### 1. Memoization
중복되는 계산이 있으면 **한 번만 계산**해서 메모해두고 그 이후에는 메모를 참고하는 방식을 Memoization이라고 한다. 

그럼 프로그래밍에서는 Memoization을 어떻게 할 수 있을까?
-> 어떤 문제를 풀 때, 시작하기 전에 파이썬 사전을 만들어 놓는다. 한 번 계산한 값은 모두 여기에 저장된다. 보통 이렇게 다시 쓸 값들을 저장해놓는 공간을 **cache**라고 한다. 

### 2. Tabulation
Memoization 에서는 fib(6)을 구하기 위해서 fib(5)와 fib(4)를 구해야 하고, fib(5)를 구하기 위해서는 fib(4)와 fib(3)을 구해야하고, fib(4)를 구하기 위해서는 fib(3)과 fib(2)를 구해야 하고... 이런 식으로 <u>맨 위에서부터 시작해서 하나씩 내려가는 사고방식을 **하향식 접근(Top-down Approach)**</u> 이라고 부른다. 

반대로 fib(6)을 구하기 위해서 fib(1)을 먼저 구하고 그 다음에 fib(2)를 구하고 그 다음에 fib(3)을 구하고 그 다음에 fib(4)를 구하고... 이런 식으로 <u>아래에서 위로 올라가는 방식은 **상향식 접근(Bottom-up Approach)**</u> 이라고 한다. > 이렇게 하면 중복되는 계산이 없음
| **n** | 1 | 2 | 3 | 4 | 5 | 6 | ... |
|---|---|---|---|---|---|---|---|
|fib(x)|1|1|2|3|5|8|...|

이런 식으로 표를 채워 나가는 느낌. 표는 영어로 Table. 즉 **Tabulation**은 **'Table 방식으로 정리한다'** 는 뜻이다. 

이러한 Tabulation은 재귀를 기반으로 코드를 작성하는 Memoization과는 달리 반복문을 사용해서 리스트를 채워 나가게 된다는 특징을 가진다.

### * Memoization vs Tabulation 어떤 방식이 더 효율적일까?

**Memoization과 Tabulation의 공통점:**
둘 다 중복되는 부분 문제의 비효율을 해결

**Memoization과 Tabulation의 차이점:**
Memoization은 일반적으로 재귀함수를 사용하고, Tabulation은  반복문을 사용한다.

Memoization은 위에서부터 필요한 계산이 무엇인지 요구를 하는 것이므로 필요 없는 계산은 안해도 된다는 장점이 있다. 그러나 Memoization을 사용하면 재귀함수를 써야 하는데 재귀 호출이 너무 많이 일어나면 Stack이 계속 쌓이고, 결국에 과부하가 걸려서 오류가 날 수도 있다는 단점이 있다.

반면에 Tabulation은 반복문을 사용하기 때문에 과부하가 걸려 오류가 날 위험이 없다. 하지만 표를 하나씩 채워 올라가는 방식이기 때문에 n번째 값을 구하기 위해서 처음부터 모두 계산하므로 어쩌면 중간에 필요 없는 것들까지 계산하게 될 수도 있다는 단점이 있다.

